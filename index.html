<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Centelha - Assistente Inteligente | Oficina FG Motos</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Google Fonts: Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide-react@0.378.0/dist/lucide.min.js"></script>

    <style>
        /* Estilização base com um tema mais sofisticado */
        body {
            font-family: 'Inter', sans-serif;
            background: #111827; /* Fundo escuro */
        }

        /* Animação para surgimento suave das mensagens */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .chat-message {
            animation: fadeIn 0.3s ease-out;
        }

        /* Estilização da barra de rolagem */
        #chat-window::-webkit-scrollbar { width: 6px; }
        #chat-window::-webkit-scrollbar-track { background: transparent; }
        #chat-window::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 10px; }
        #chat-window::-webkit-scrollbar-thumb:hover { background: #6b7280; }

        /* Animação para o indicador de "digitando..." */
        .typing-indicator span {
            height: 8px;
            width: 8px;
            float: left;
            margin: 0 1px;
            background-color: #9ca3af;
            display: block;
            border-radius: 50%;
            opacity: 0.4;
            animation: bob 1s infinite;
        }
        .typing-indicator span:nth-of-type(2) { animation-delay: 0.2s; }
        .typing-indicator span:nth-of-type(3) { animation-delay: 0.4s; }
        @keyframes bob {
            10% { transform: translateY(-6px); opacity: 1; }
            50% { transform: translateY(0); opacity: 0.4; }
        }
    </style>
</head>
<body class="flex items-center justify-center h-screen p-4">

    <!-- Container Principal do Chat -->
    <div id="chat-container" class="w-full max-w-lg h-full sm:h-[95vh] sm:max-h-[750px] bg-gray-800 text-white rounded-2xl shadow-2xl flex flex-col overflow-hidden border border-gray-700">
        
        <!-- Cabeçalho do Chat -->
        <div id="chat-header" class="bg-gray-900/80 backdrop-blur-sm p-4 flex items-center justify-between gap-4 shadow-lg z-10 border-b border-gray-700">
            <div class="flex items-center gap-3">
                <div class="w-12 h-12 bg-gradient-to-br from-yellow-400 to-orange-500 rounded-full flex items-center justify-center shadow-lg ring-2 ring-yellow-500/50">
                    <i data-lucide="sparkles" class="h-6 w-6 text-white"></i>
                </div>
                <div>
                    <h2 class="text-white text-lg font-bold">Centelha</h2>
                    <span id="status-indicator" class="text-green-400 text-xs flex items-center gap-1.5"><div class="w-2 h-2 bg-green-400 rounded-full animate-pulse"></div>Online</span>
                </div>
            </div>
            <button id="new-chat-btn" title="Nova Conversa" class="p-2 text-gray-400 hover:text-white hover:bg-gray-700 rounded-full transition-colors">
                <i data-lucide="rotate-cw" class="h-5 w-5"></i>
            </button>
        </div>

        <!-- Janela de Mensagens -->
        <div id="chat-window" class="flex-1 p-4 sm:p-6 overflow-y-auto bg-gray-800">
            <div id="chat-messages" class="flex flex-col gap-4">
                <!-- Mensagens inseridas via JavaScript -->
            </div>
        </div>
        
        <!-- Sugestões de Respostas Rápidas -->
        <div id="quick-replies-container" class="p-2 pt-0 flex flex-wrap gap-2 justify-start px-4">
            <!-- Botões de resposta rápida inseridos aqui -->
        </div>

        <!-- Área de Input -->
        <div id="chat-input-container" class="p-4 bg-gray-800 border-t border-gray-700">
            <div class="flex items-center bg-gray-900 rounded-full px-2">
                <input type="text" id="chat-input" placeholder="Digite sua mensagem..." class="flex-1 bg-transparent p-3 text-gray-200 placeholder-gray-500 focus:outline-none">
                <button id="send-btn" class="p-3 rounded-full bg-gradient-to-br from-yellow-400 to-orange-500 hover:opacity-90 transition-opacity disabled:opacity-50 disabled:cursor-not-allowed">
                    <i data-lucide="send" class="h-6 w-6 text-white"></i>
                </button>
            </div>
        </div>
    </div>
    
    <!-- Modal de Confirmação -->
    <div id="confirmation-modal" class="fixed inset-0 bg-black/60 items-center justify-center hidden z-50">
        <div class="bg-gray-800 border border-gray-700 rounded-lg p-6 shadow-xl max-w-sm mx-4 text-center">
            <h3 class="text-lg font-bold text-white mb-2">Confirmar Ação</h3>
            <p id="modal-text" class="text-gray-300 mb-6">Você tem certeza que deseja iniciar uma nova conversa? Todo o histórico atual será perdido.</p>
            <div class="flex justify-center gap-4">
                <button id="cancel-btn" class="px-4 py-2 bg-gray-600 hover:bg-gray-500 text-white font-semibold rounded-lg transition-colors">Cancelar</button>
                <button id="confirm-btn" class="px-4 py-2 bg-red-600 hover:bg-red-500 text-white font-semibold rounded-lg transition-colors">Confirmar</button>
            </div>
        </div>
    </div>


    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, collection, addDoc, onSnapshot, query, serverTimestamp, orderBy, deleteDoc, getDocs, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- Variáveis Globais de Configuração (NÃO ALTERAR) ---
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'centelha-dev';
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
        const API_KEY = ""; // A chave é injetada pelo ambiente de execução

        // --- Elementos do DOM ---
        const elements = {
            chatInput: document.getElementById('chat-input'),
            sendBtn: document.getElementById('send-btn'),
            chatMessages: document.getElementById('chat-messages'),
            chatWindow: document.getElementById('chat-window'),
            newChatBtn: document.getElementById('new-chat-btn'),
            quickRepliesContainer: document.getElementById('quick-replies-container'),
            modal: {
                container: document.getElementById('confirmation-modal'),
                text: document.getElementById('modal-text'),
                cancelBtn: document.getElementById('cancel-btn'),
                confirmBtn: document.getElementById('confirm-btn')
            }
        };

        // --- Estado da Aplicação ---
        let appState = {
            isAuthReady: false,
            userId: null,
            chatId: null,
            isThinking: false,
            conversationHistory: [],
            customerData: { name: '', moto: '', problem: '' },
            db: null,
            auth: null,
            unsubscribe: null, // Para o listener do onSnapshot
        };
        
        // --- CÉREBRO DA CENTELHA: Instruções para a IA ---
        const systemPrompt = `
            Você é a Centelha, uma assistente virtual especialista em motocicletas da "Oficina FG Motos".
            Sua personalidade é amigável, técnica, eficiente e muito confiável.
            Seu objetivo principal é coletar três informações do cliente: NOME, MODELO DA MOTO e o PROBLEMA.
            Você deve conduzir a conversa de forma natural para obter esses dados.

            RESPONDA SEMPRE EM FORMATO JSON com a seguinte estrutura:
            {
              "responseText": "Sua resposta amigável e conversacional para o usuário.",
              "conversationState": "STATE",
              "extractedData": { "name": "...", "moto": "...", "problem": "..." },
              "quickReplies": ["Opção 1", "Opção 2"]
            }

            REGRAS DE LÓGICA:
            1.  'conversationState': Mude o estado conforme o andamento. Os estados são:
                - ASKING_FOR_DATA: Quando você ainda precisa de alguma informação (nome, moto ou problema).
                - READY_FOR_DIAGNOSIS: Quando você JÁ TEM o nome, a moto E o problema.
                - GIVING_DIAGNOSIS: Quando você está fornecendo o diagnóstico.
                - HANDOFF: Quando você está se preparando para transferir para o WhatsApp.
                - GENERAL_QUESTION: Se o usuário fez uma pergunta geral (ex: endereço).

            2.  'extractedData': Preencha com os dados que você conseguir extrair da MENSAGEM MAIS RECENTE do usuário. Mantenha os dados já coletados de mensagens anteriores. Se o usuário corrigir uma informação, atualize-a.

            3.  'quickReplies': Ofereça sugestões de respostas para o usuário QUANDO FIZER SENTIDO. Por exemplo, se perguntar o problema, pode sugerir ["Não liga", "Faz barulho estranho", "Pneu furado"]. Mantenha o array vazio ([]) se não houver sugestões.

            4.  'responseText': Formule uma resposta clara. Se precisar de mais dados, peça o próximo. Ex: "Prazer, [Nome]! E qual a marca e modelo da sua moto?". Se identificar uma pergunta geral (endereço, horário), responda-a e depois volte ao fluxo principal.

            5.  NÃO use markdown (como *, #, etc.) na sua 'responseText'.
            
            INFORMAÇÕES DA OFICINA:
            - Endereço: Av. Fabio Zahran, 6628, Vila Carvalho, Campo Grande-MS.
            - WhatsApp: 5567999271603
            - Horário: Segunda a Sexta, das 8h às 18h.
        `;

        // --- Funções da Interface (UI) ---

        function toggleThinking(isThinking) {
            appState.isThinking = isThinking;
            elements.chatInput.disabled = isThinking;
            elements.sendBtn.disabled = isThinking;
            elements.chatInput.placeholder = isThinking ? "Centelha está digitando..." : "Digite sua mensagem...";
            
            // Remove o indicador de digitação antigo se existir
            const typingIndicator = document.querySelector('.typing-indicator-container');
            if (typingIndicator) typingIndicator.remove();
            
            if (isThinking) {
                const indicatorHTML = `
                    <div class="w-full flex justify-start typing-indicator-container chat-message">
                        <div class="bg-gray-700 text-gray-800 p-3 rounded-2xl rounded-bl-lg max-w-sm">
                            <div class="typing-indicator"><span></span><span></span><span></span></div>
                        </div>
                    </div>`;
                elements.chatMessages.insertAdjacentHTML('beforeend', indicatorHTML);
                scrollToBottom();
            }
        }
        
        function addMessageToUI(sender, text, quickReplies = []) {
             // Remove o indicador de digitação antes de adicionar a nova mensagem
            const typingIndicator = document.querySelector('.typing-indicator-container');
            if (typingIndicator) typingIndicator.remove();

            const messageContainer = document.createElement('div');
            messageContainer.className = `w-full flex chat-message ${sender === 'user' ? 'justify-end' : 'justify-start'}`;
            
            const buttonRegex = /\[BUTTON:(.+?)\|(.+?)\]/g;
            const textWithButtons = text.replace(buttonRegex, (match, buttonText, url) => {
                return `<a href="${url}" target="_blank" class="chat-button block text-center mt-3 bg-gradient-to-br from-yellow-400 to-orange-500 text-white font-bold py-2.5 px-4 rounded-full hover:opacity-90 transition-opacity no-underline">${buttonText}</a>`;
            });

            const messageBubble = sender === 'user'
                ? `<div class="bg-gradient-to-br from-yellow-400 to-orange-500 text-white p-3 rounded-2xl rounded-br-lg max-w-md shadow-md"><p>${textWithButtons}</p></div>`
                : `<div class="bg-gray-700 text-gray-100 p-3 rounded-2xl rounded-bl-lg max-w-md shadow-md"><p>${textWithButtons}</p></div>`;
            
            messageContainer.innerHTML = messageBubble;
            elements.chatMessages.appendChild(messageContainer);
            renderQuickReplies(quickReplies);
            scrollToBottom();
        }

        function renderQuickReplies(replies = []) {
            elements.quickRepliesContainer.innerHTML = '';
            if (replies.length === 0) return;

            replies.forEach(reply => {
                const button = document.createElement('button');
                button.textContent = reply;
                button.className = "px-3 py-1.5 bg-gray-700 text-gray-200 rounded-full text-sm hover:bg-gray-600 transition-colors";
                button.onclick = () => {
                    elements.chatInput.value = reply;
                    handleSend();
                };
                elements.quickRepliesContainer.appendChild(button);
            });
        }
        
        function scrollToBottom() {
            elements.chatWindow.scrollTop = elements.chatWindow.scrollHeight;
        }
        
        function showModal(text, onConfirm) {
            elements.modal.text.textContent = text;
            elements.modal.container.classList.remove('hidden');
            elements.modal.container.classList.add('flex');
            
            // Clone and replace to remove old event listeners
            const newConfirmBtn = elements.modal.confirmBtn.cloneNode(true);
            elements.modal.confirmBtn.parentNode.replaceChild(newConfirmBtn, elements.modal.confirmBtn);
            elements.modal.confirmBtn = newConfirmBtn;
            
            elements.modal.confirmBtn.onclick = () => {
                onConfirm();
                hideModal();
            };
        }

        function hideModal() {
            elements.modal.container.classList.add('hidden');
            elements.modal.container.classList.remove('flex');
        }

        // --- Funções do Firestore ---

        async function saveMessage(sender, text) {
            if (!appState.isAuthReady || !appState.chatId) return;
            try {
                const messagesCol = collection(appState.db, `artifacts/${appId}/users/${appState.userId}/chats/${appState.chatId}/messages`);
                await addDoc(messagesCol, {
                    sender,
                    text,
                    createdAt: serverTimestamp()
                });
            } catch (error) {
                console.error("Erro ao salvar mensagem:", error);
            }
        }
        
        function listenToMessages() {
            if (appState.unsubscribe) appState.unsubscribe(); // Cancela listener anterior
            
            const messagesCol = collection(appState.db, `artifacts/${appId}/users/${appState.userId}/chats/${appState.chatId}/messages`);
            const q = query(messagesCol, orderBy("createdAt"));

            appState.unsubscribe = onSnapshot(q, (snapshot) => {
                if (snapshot.empty && appState.conversationHistory.length === 0) {
                     // Se não houver mensagens no Firestore, inicia a conversa
                    toggleThinking(true);
                    setTimeout(() => {
                        const welcomeMessage = "Olá! Sou a Centelha, sua assistente da Oficina FG Motos. Para começarmos, qual o seu nome?";
                        addMessageToUI('assistant', welcomeMessage, ["Meu nome é...", "Queria saber o endereço"]);
                        saveMessage('assistant', welcomeMessage);
                        appState.conversationHistory.push({ role: 'model', parts: [{ text: welcomeMessage }] });
                        toggleThinking(false);
                    }, 500);
                } else {
                    snapshot.docChanges().forEach((change) => {
                        if (change.type === "added") {
                            const data = change.doc.data();
                            const messageExists = appState.conversationHistory.some(
                                msg => msg.parts[0].text === data.text && msg.role === (data.sender === 'user' ? 'user' : 'model')
                            );
                            if (!messageExists) {
                                addMessageToUI(data.sender, data.text);
                                appState.conversationHistory.push({
                                    role: data.sender === 'user' ? 'user' : 'model',
                                    parts: [{ text: data.text }]
                                });
                            }
                        }
                    });
                }
            }, (error) => {
                console.error("Erro ao ouvir mensagens:", error);
            });
        }
        
        async function createNewChat() {
            if (!appState.isAuthReady) return;
            toggleThinking(true);
            elements.chatMessages.innerHTML = '';
            appState.conversationHistory = [];
            
            try {
                const chatsCol = collection(appState.db, `artifacts/${appId}/users/${appState.userId}/chats`);
                const newChatRef = await addDoc(chatsCol, { createdAt: serverTimestamp() });
                appState.chatId = newChatRef.id;
                listenToMessages();
            } catch (error) {
                console.error("Erro ao criar novo chat:", error);
                toggleThinking(false);
            }
        }

        async function findOrCreateChat() {
            if (!appState.isAuthReady) return;
            const chatsCol = collection(appState.db, `artifacts/${appId}/users/${appState.userId}/chats`);
            const q = query(chatsCol, orderBy("createdAt", "desc"));
            const querySnapshot = await getDocs(q);
            
            if (querySnapshot.empty) {
                await createNewChat();
            } else {
                appState.chatId = querySnapshot.docs[0].id;
                listenToMessages();
            }
        }
        
        async function clearChatHistory() {
             if (!appState.isAuthReady || !appState.chatId) return;
             const messagesCol = collection(appState.db, `artifacts/${appId}/users/${appState.userId}/chats/${appState.chatId}/messages`);
             const snapshot = await getDocs(messagesCol);
             const deletePromises = snapshot.docs.map(doc => deleteDoc(doc.ref));
             await Promise.all(deletePromises);
             
             const chatDoc = doc(appState.db, `artifacts/${appId}/users/${appState.userId}/chats`, appState.chatId);
             await deleteDoc(chatDoc);
             
             appState.chatId = null;
             appState.conversationHistory = [];
             elements.chatMessages.innerHTML = '';
             await findOrCreateChat();
        }

        // --- Funções da IA (Gemini) ---

        async function callGeminiAPI(currentHistory, useJsonSchema = true) {
            const payload = {
                contents: [
                    { role: "user", parts: [{ text: systemPrompt }] },
                    ...currentHistory
                ],
                generationConfig: {
                    maxOutputTokens: 500,
                    temperature: 0.7,
                }
            };
            
            if (useJsonSchema) {
                payload.generationConfig.responseMimeType = "application/json";
                payload.generationConfig.responseSchema = {
                    type: "OBJECT",
                    properties: {
                        "responseText": { "type": "STRING" },
                        "conversationState": { "type": "STRING" },
                        "extractedData": {
                            type: "OBJECT",
                            properties: {
                                "name": { "type": "STRING" },
                                "moto": { "type": "STRING" },
                                "problem": { "type": "STRING" }
                            }
                        },
                        "quickReplies": { "type": "ARRAY", "items": { "type": "STRING" } }
                    }
                };
            }

            const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${API_KEY}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                throw new Error(`API call failed with status: ${response.status}`);
            }
            return response.json();
        }

        async function getDiagnosis() {
            toggleThinking(true);
            const diagnosisPrompt = `
                Baseado nos dados coletados, forneça um diagnóstico preliminar para o cliente.
                CLIENTE: ${appState.customerData.name}
                MOTO: ${appState.customerData.moto}
                PROBLEMA: ${appState.customerData.problem}

                Forneça 2 ou 3 causas mais comuns para o problema descrito, de forma clara e simples.
                Ao final, inclua OBRIGATORIAMENTE este aviso: "Lembre-se, ${appState.customerData.name}, que esta é uma análise inicial. Para um diagnóstico preciso e seguro, o ideal é trazer sua ${appState.customerData.moto} para nossos mecânicos avaliarem aqui na oficina."
            `;
            
            try {
                const diagnosisHistory = [...appState.conversationHistory, { role: 'user', parts: [{ text: diagnosisPrompt }] }];
                const data = await callGeminiAPI(diagnosisHistory, false);
                
                if (data.candidates?.[0]?.content?.parts?.[0]?.text) {
                    const diagnosisText = data.candidates[0].content.parts[0].text.trim();
                    addMessageToUI('assistant', diagnosisText);
                    saveMessage('assistant', diagnosisText);
                    appState.conversationHistory.push({ role: 'model', parts: [{ text: diagnosisText }] });
                    
                    setTimeout(generateWhatsAppLink, 1000);
                } else {
                    throw new Error('Resposta de diagnóstico inválida.');
                }
            } catch (error) {
                console.error("Diagnosis Error:", error);
                const errorMsg = 'Não consegui gerar um diagnóstico agora, mas não se preocupe. Vamos pular direto para o atendimento com nossa equipe.';
                addMessageToUI('assistant', errorMsg);
                saveMessage('assistant', errorMsg);
                generateWhatsAppLink();
            } finally {
                toggleThinking(false);
            }
        }
        
        function generateWhatsAppLink() {
            const introText = "Olá! Vim através da assistente Centelha.";
            const summary = `\n\n*Resumo do Atendimento:*\n- *Cliente:* ${appState.customerData.name}\n- *Moto:* ${appState.customerData.moto}\n- *Problema:* ${appState.customerData.problem}`;
            const encodedText = encodeURIComponent(introText + summary);
            const whatsappUrl = `https://wa.me/5567999271603?text=${encodedText}`;
            
            const transferMessage = `Obrigado pelas informações! Para agilizar seu atendimento, preparei um resumo. Clique no botão abaixo para enviar a mensagem já pronta no seu WhatsApp e falar com nossa equipe. [BUTTON:Falar com a Equipe|${whatsappUrl}]`;
            
            addMessageToUI('assistant', transferMessage);
            saveMessage('assistant', transferMessage);
        }

        // --- Lógica Principal da Conversa ---

        async function handleConversation(userInput) {
            toggleThinking(true);
            appState.conversationHistory.push({ role: 'user', parts: [{ text: userInput }] });

            try {
                const data = await callGeminiAPI(appState.conversationHistory);
                
                if (data.candidates?.[0]?.content?.parts?.[0]?.text) {
                    const jsonResponse = JSON.parse(data.candidates[0].content.parts[0].text);
                    
                    // Atualiza o estado com os dados extraídos
                    appState.customerData = { ...appState.customerData, ...jsonResponse.extractedData };
                    
                    const assistantResponse = jsonResponse.responseText;
                    addMessageToUI('assistant', assistantResponse, jsonResponse.quickReplies);
                    saveMessage('assistant', assistantResponse);
                    appState.conversationHistory.push({ role: 'model', parts: [{ text: assistantResponse }] });

                    // Verifica se já pode fazer o diagnóstico
                    if (jsonResponse.conversationState === 'READY_FOR_DIAGNOSIS' || 
                       (appState.customerData.name && appState.customerData.moto && appState.customerData.problem)) {
                       setTimeout(getDiagnosis, 500);
                    }

                } else {
                    throw new Error('Resposta da API inválida.');
                }
            } catch (error) {
                console.error("Conversation Error:", error);
                const errorMsg = "Desculpe, tive um pequeno curto-circuito aqui. Você poderia repetir sua última mensagem, por favor?";
                addMessageToUI('assistant', errorMsg);
                saveMessage('assistant', errorMsg);
                // Remove a última mensagem do usuário do histórico para tentar de novo
                appState.conversationHistory.pop(); 
            } finally {
                if(appState.customerData.name && appState.customerData.moto && appState.customerData.problem) {
                    // Não para de pensar se já vai direto pro diagnóstico
                } else {
                    toggleThinking(false);
                }
            }
        }
        
        async function handleSend() {
            const userInput = elements.chatInput.value.trim();
            if (userInput === '' || appState.isThinking) return;

            addMessageToUI('user', userInput);
            saveMessage('user', userInput);
            elements.chatInput.value = '';
            renderQuickReplies([]); // Limpa as sugestões após o envio

            await handleConversation(userInput);
        }

        // --- Inicialização e Event Listeners ---

        async function startApp() { // <-- RENOMEADO AQUI
            lucide.createIcons(); // Inicializa os ícones
            
            elements.sendBtn.addEventListener('click', handleSend);
            elements.chatInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') handleSend() });
            elements.newChatBtn.addEventListener('click', () => {
                showModal("Tem certeza que deseja apagar esta conversa e começar uma nova?", () => {
                   clearChatHistory();
                });
            });
            elements.modal.cancelBtn.addEventListener('click', hideModal);
            
            try {
                setLogLevel('error');
                const app = initializeApp(firebaseConfig); // <-- Uso da função importada
                appState.db = getFirestore(app);
                appState.auth = getAuth(app);
                
                onAuthStateChanged(appState.auth, async (user) => {
                    if (user) {
                        appState.userId = user.uid;
                        appState.isAuthReady = true;
                        await findOrCreateChat();
                    }
                });

                if (initialAuthToken) {
                    await signInWithCustomToken(appState.auth, initialAuthToken);
                } else {
                    await signInAnonymously(appState.auth);
                }

            } catch (error) {
                console.error("Falha na inicialização do Firebase:", error);
                addMessageToUI('assistant', 'Erro de conexão. Não consigo salvar seu histórico. Por favor, recarregue a página.');
                toggleThinking(true); // Bloqueia o app
            }
        }

        window.onload = startApp; // <-- ATUALIZADO AQUI
    </script>
</body>
</html>
