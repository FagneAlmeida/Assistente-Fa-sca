<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Centelha - Assistente Inteligente | Oficina FG Motos</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Google Fonts: Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@0.378.0/dist/umd/lucide.min.js"></script>

    <style>
        body {
            font-family: 'Inter', sans-serif;
            background: #111827;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .chat-message {
            animation: fadeIn 0.3s ease-out;
        }
        #chat-window::-webkit-scrollbar { width: 6px; }
        #chat-window::-webkit-scrollbar-track { background: transparent; }
        #chat-window::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 10px; }
        #chat-window::-webkit-scrollbar-thumb:hover { background: #6b7280; }
        .typing-indicator span {
            height: 8px; width: 8px; float: left; margin: 0 1px;
            background-color: #9ca3af; display: block;
            border-radius: 50%; opacity: 0.4;
            animation: bob 1s infinite;
        }
        .typing-indicator span:nth-of-type(2) { animation-delay: 0.2s; }
        .typing-indicator span:nth-of-type(3) { animation-delay: 0.4s; }
        @keyframes bob {
            10% { transform: translateY(-6px); opacity: 1; }
            50% { transform: translateY(0); opacity: 0.4; }
        }
        .chat-action-button {
            text-decoration: none !important;
            display: block; text-align: center; margin-top: 0.75rem;
            font-weight: 700; padding: 10px 16px; border-radius: 9999px;
            transition: opacity 0.2s; cursor: pointer; border: none;
        }
        .chat-action-button:hover { opacity: 0.9; }
    </style>
</head>
<body class="flex items-center justify-center h-screen p-4">

    <!-- Container Principal do Chat -->
    <div id="chat-container" class="w-full max-w-lg h-full sm:h-[95vh] sm:max-h-[750px] bg-gray-800 text-white rounded-2xl shadow-2xl flex flex-col overflow-hidden border border-gray-700">
        
        <!-- Cabeçalho do Chat -->
        <div id="chat-header" class="bg-gray-900/80 backdrop-blur-sm p-4 flex items-center justify-between gap-4 shadow-lg z-10 border-b border-gray-700">
            <div class="flex items-center gap-3">
                <div class="w-12 h-12 bg-gradient-to-br from-yellow-400 to-orange-500 rounded-full flex items-center justify-center shadow-lg ring-2 ring-yellow-500/50">
                    <i data-lucide="sparkles" class="h-6 w-6 text-white"></i>
                </div>
                <div>
                    <h2 class="text-white text-lg font-bold">Centelha</h2>
                    <span id="status-indicator" class="text-green-400 text-xs flex items-center gap-1.5"><div class="w-2 h-2 bg-green-400 rounded-full animate-pulse"></div>Online</span>
                </div>
            </div>
            <button id="new-chat-btn" title="Nova Conversa" class="p-2 text-gray-400 hover:text-white hover:bg-gray-700 rounded-full transition-colors">
                <i data-lucide="rotate-cw" class="h-5 w-5"></i>
            </button>
        </div>

        <!-- Janela de Mensagens -->
        <div id="chat-window" class="flex-1 p-4 sm:p-6 overflow-y-auto bg-gray-800">
            <div id="chat-messages" class="flex flex-col gap-4"></div>
        </div>
        
        <!-- Sugestões de Respostas Rápidas -->
        <div id="quick-replies-container" class="p-2 pt-0 flex flex-wrap gap-2 justify-start px-4"></div>

        <!-- Área de Input -->
        <div id="chat-input-container" class="p-4 bg-gray-800 border-t border-gray-700">
            <div class="flex items-center bg-gray-900 rounded-full px-2">
                <input type="text" id="chat-input" placeholder="Digite a sua mensagem..." class="flex-1 bg-transparent p-3 text-gray-200 placeholder-gray-500 focus:outline-none">
                <button id="send-btn" class="p-3 rounded-full bg-gradient-to-br from-yellow-400 to-orange-500 hover:opacity-90 transition-opacity disabled:opacity-50 disabled:cursor-not-allowed">
                    <i data-lucide="send" class="h-6 w-6 text-white"></i>
                </button>
            </div>
        </div>
    </div>
    
    <!-- Modal de Confirmação -->
    <div id="confirmation-modal" class="fixed inset-0 bg-black/60 items-center justify-center hidden z-50">
        <div class="bg-gray-800 border border-gray-700 rounded-lg p-6 shadow-xl max-w-sm mx-4 text-center">
            <h3 class="text-lg font-bold text-white mb-2">Confirmar Ação</h3>
            <p id="modal-text" class="text-gray-300 mb-6">Tem a certeza de que deseja iniciar uma nova conversa? Todo o histórico atual será perdido.</p>
            <div class="flex justify-center gap-4">
                <button id="cancel-btn" class="px-4 py-2 bg-gray-600 hover:bg-gray-500 text-white font-semibold rounded-lg transition-colors">Cancelar</button>
                <button id="confirm-btn" class="px-4 py-2 bg-red-600 hover:bg-red-500 text-white font-semibold rounded-lg transition-colors">Confirmar</button>
            </div>
        </div>
    </div>

    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, addDoc, onSnapshot, query, serverTimestamp, orderBy, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- Configuração da Aplicação ---
        const config = {
            whatsappNumber: "5567999271603",
            // A URL DA SUA CLOUD FUNCTION!
            backendApiUrl: "https://callgemini-g3vol52jhq-uc.a.run.app"
        };
        
        const systemPrompt = `Você é a Centelha, uma assistente virtual especialista em motocicletas da "Oficina FG Motos". Sua personalidade é amigável, técnica e eficiente. Seu objetivo é coletar NOME, MODELO DA MOTO e o PROBLEMA. RESPONDA SEMPRE EM FORMATO JSON VÁLIDO com a seguinte estrutura: {"responseText": "Sua resposta conversacional para o usuário.", "conversationState": "STATE", "extractedData": { "name": "...", "moto": "...", "problem": "..." }, "quickReplies": ["Opção 1", "Opção 2"]}. REGRAS: 1. 'conversationState': Mude o estado: ASKING_FOR_DATA, READY_FOR_DIAGNOSIS, GENERAL_QUESTION. 2. 'extractedData': Preencha com os dados da MENSAGEM MAIS RECENTE. Mantenha os dados já coletados. 3. 'quickReplies': Ofereça sugestões ÚTEIS. 4. 'responseText': Seja claro. Peça um dado de cada vez. 5. NUNCA use markdown. INFORMAÇÕES DA OFICINA: Endereço: Av. Fabio Zahran, 6628, Vila Carvalho, Campo Grande-MS. WhatsApp: +5567999271603. Horário: Segunda a Sexta, das 8h às 18h.`;

        const elements = {
            chatInput: document.getElementById('chat-input'), sendBtn: document.getElementById('send-btn'),
            chatMessages: document.getElementById('chat-messages'), chatWindow: document.getElementById('chat-window'),
            newChatBtn: document.getElementById('new-chat-btn'), quickRepliesContainer: document.getElementById('quick-replies-container'),
            modal: { container: document.getElementById('confirmation-modal'), text: document.getElementById('modal-text'), cancelBtn: document.getElementById('cancel-btn'), confirmBtn: document.getElementById('confirm-btn') }
        };

        let appState = {
            isAuthReady: false, userId: null, chatId: null, isThinking: false,
            conversationHistory: [], customerData: { name: '', moto: '', problem: '', preAnalysis: '' },
            db: null, auth: null, unsubscribe: null, 
            appId: typeof __app_id !== 'undefined' ? __app_id : 'default-app-id',
            renderedMessageIds: new Set()
        };
        
        function toggleThinking(isThinking) {
            appState.isThinking = isThinking;
            elements.chatInput.disabled = isThinking;
            elements.sendBtn.disabled = isThinking;
            elements.chatInput.placeholder = isThinking ? "Centelha está a pensar..." : "Digite a sua mensagem...";
            const typingIndicator = document.querySelector('.typing-indicator-container');
            if (typingIndicator) typingIndicator.remove();
            if (isThinking) {
                const indicatorHTML = `<div class="w-full flex justify-start typing-indicator-container chat-message"><div class="bg-gray-700 text-gray-800 p-3 rounded-2xl rounded-bl-lg max-w-sm"><div class="typing-indicator"><span></span><span></span><span></span></div></div></div>`;
                elements.chatMessages.insertAdjacentHTML('beforeend', indicatorHTML);
                scrollToBottom();
            } else {
                elements.chatInput.focus();
            }
        }
        
        function addMessageToUI(sender, text, messageId) {
            if (messageId && appState.renderedMessageIds.has(messageId)) return;
            if (messageId) appState.renderedMessageIds.add(messageId);

            const typingIndicator = document.querySelector('.typing-indicator-container');
            if (typingIndicator) typingIndicator.remove();

            const messageContainer = document.createElement('div');
            messageContainer.className = `w-full flex chat-message ${sender === 'user' ? 'justify-end' : 'justify-start'}`;
            
            const buttonRegex = /\[BUTTON:([^|]+)\|([^\]]+)\]/g;
            const copyButtonRegex = /\[COPYBUTTON:([^|]+)\|([^\]]+)\]/g;
            let sanitizedText = text.replace(/</g, "&lt;").replace(/>/g, "&gt;");
            
            let htmlText = sanitizedText
                .replace(buttonRegex, (match, buttonText, url) => `<a href="${url}" target="_blank" class="chat-action-button bg-gradient-to-br from-yellow-400 to-orange-500 text-white">${buttonText}</a>`)
                .replace(copyButtonRegex, (match, buttonText, textToCopy) => `<button data-copytext="${textToCopy.replace(/"/g, '&quot;')}" class="chat-action-button bg-gray-600 text-white">${buttonText}</button>`);

            const messageBubble = sender === 'user'
                ? `<div class="bg-gradient-to-br from-yellow-400 to-orange-500 text-white p-3 rounded-2xl rounded-br-lg max-w-md shadow-md"><p>${htmlText}</p></div>`
                : `<div class="bg-gray-700 text-gray-100 p-3 rounded-2xl rounded-bl-lg max-w-md shadow-md"><p>${htmlText}</p></div>`;
            
            messageContainer.innerHTML = messageBubble;
            elements.chatMessages.appendChild(messageContainer);
            scrollToBottom();
        }

        function renderQuickReplies(replies = []) {
            elements.quickRepliesContainer.innerHTML = '';
            if (!replies || replies.length === 0) return;
            replies.forEach(reply => {
                const button = document.createElement('button');
                button.textContent = reply;
                button.className = "px-3 py-1.5 bg-gray-700 text-gray-200 rounded-full text-sm hover:bg-gray-600 transition-colors";
                button.onclick = () => { elements.chatInput.value = reply; handleSend(); };
                elements.quickRepliesContainer.appendChild(button);
            });
        }
        
        function scrollToBottom() { elements.chatWindow.scrollTop = elements.chatWindow.scrollHeight; }
        
        function showModal(text, onConfirm) {
            elements.modal.text.textContent = text;
            elements.modal.container.classList.remove('hidden');
            elements.modal.container.classList.add('flex');
            const newConfirmBtn = elements.modal.confirmBtn.cloneNode(true);
            elements.modal.confirmBtn.parentNode.replaceChild(newConfirmBtn, elements.modal.confirmBtn);
            elements.modal.confirmBtn = newConfirmBtn;
            elements.modal.confirmBtn.onclick = () => { onConfirm(); hideModal(); };
        }

        function hideModal() {
            elements.modal.container.classList.add('hidden');
            elements.modal.container.classList.remove('flex');
        }
        
        async function saveMessage(sender, text) {
            if (!appState.isAuthReady || !appState.chatId || !appState.db) return null;
            try {
                const messagesCol = collection(appState.db, `artifacts/${appState.appId}/users/${appState.userId}/chats/${appState.chatId}/messages`);
                const docRef = await addDoc(messagesCol, { sender, text, createdAt: serverTimestamp() });
                return docRef.id;
            } catch (error) {
                console.error("Erro ao guardar mensagem:", error);
                return null;
            }
        }
        
        // CORREÇÃO: Lógica do listener refeita para orquestrar a conversa e evitar a condição de corrida.
        function listenToMessages() {
            if (appState.unsubscribe) appState.unsubscribe();
            const messagesCol = collection(appState.db, `artifacts/${appState.appId}/users/${appState.userId}/chats/${appState.chatId}/messages`);
            const q = query(messagesCol, orderBy("createdAt"));

            appState.unsubscribe = onSnapshot(q, (snapshot) => {
                // Limpa e redesenha a UI e o estado a partir do Firestore (fonte da verdade)
                elements.chatMessages.innerHTML = '';
                appState.renderedMessageIds.clear();
                appState.conversationHistory = [];

                snapshot.docs.forEach(doc => {
                    const data = doc.data();
                    const messageId = doc.id;
                    let textForUI = data.text;
                    let textForHistory = data.text;

                    // A IA salva um JSON, mas mostramos apenas o `responseText` na UI
                    if (data.sender === 'assistant') {
                        try {
                            const parsed = JSON.parse(data.text);
                            textForUI = parsed.responseText || data.text;
                            textForHistory = JSON.stringify(parsed); // Mantém o JSON completo para o histórico
                        } catch (e) { /* Se não for JSON, usa o texto como está */ }
                    }
                    
                    addMessageToUI(data.sender, textForUI, messageId);
                    appState.conversationHistory.push({
                        role: data.sender === 'user' ? 'user' : 'model',
                        parts: [{ text: textForHistory }]
                    });
                });

                if (snapshot.empty) {
                    startConversation();
                    return;
                }

                // Verifica se a IA precisa responder
                const lastMessage = appState.conversationHistory[appState.conversationHistory.length - 1];
                if (lastMessage && lastMessage.role === 'user' && !appState.isThinking) {
                    handleConversation();
                } else if (lastMessage && lastMessage.role === 'model') {
                    // Se a última mensagem é da IA, para de pensar e mostra as respostas rápidas
                    toggleThinking(false);
                    try {
                        const lastResponse = JSON.parse(lastMessage.parts[0].text);
                        renderQuickReplies(lastResponse.quickReplies || []);
                    } catch(e) {
                        renderQuickReplies([]);
                    }
                }
            }, (error) => {
                console.error("Erro ao ouvir mensagens:", error);
                addMessageToUI('assistant', 'Não foi possível carregar o histórico. Por favor, atualize a página.', 'error-load');
                toggleThinking(false);
            });
        }
        
        async function createNewChat() {
            if (!appState.isAuthReady || !appState.db) return;
            if (appState.unsubscribe) appState.unsubscribe();
            toggleThinking(true);
            // Limpa o estado local. A função listenToMessages irá preenchê-lo.
            appState.conversationHistory = [];
            appState.customerData = { name: '', moto: '', problem: '', preAnalysis: '' };
            try {
                const chatsCol = collection(appState.db, `artifacts/${appState.appId}/users/${appState.userId}/chats`);
                const newChatRef = await addDoc(chatsCol, { createdAt: serverTimestamp(), userId: appState.userId });
                appState.chatId = newChatRef.id;
                listenToMessages(); // O listener vai detectar o chat vazio e iniciar a conversa
            } catch (error) {
                console.error("Erro ao criar novo chat:", error);
                toggleThinking(false);
            }
        }
        
        async function callBackendAPI(payload) {
            const response = await fetch(config.backendApiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            if (!response.ok) {
                const errorBody = await response.text();
                throw new Error(`A chamada ao backend falhou com status: ${response.status}. Corpo: ${errorBody}`);
            }
            return response.json();
        }

        async function getDiagnosis() {
            toggleThinking(true);
            const diagnosisPrompt = `Baseado nos dados coletados, forneça um diagnóstico preliminar para o cliente. CLIENTE: ${appState.customerData.name}, MOTO: ${appState.customerData.moto}, PROBLEMA: ${appState.customerData.problem}. Forneça 2 ou 3 causas comuns. NÃO use formatação. Ao final, inclua OBRIGATORIAMENTE este aviso: "Lembre-se, ${appState.customerData.name}, que esta é uma análise inicial. Para um diagnóstico preciso e seguro, o ideal é trazer sua ${appState.customerData.moto} para nossos mecânicos avaliarem aqui na oficina."`;
            
            try {
                const responseJson = await callBackendAPI({ history: [{ role: 'user', parts: [{ text: diagnosisPrompt }] }], systemPrompt });
                appState.customerData.preAnalysis = responseJson.responseText.trim();
                // Salva a resposta do diagnóstico. O listener vai renderizar e parar o "thinking".
                await saveMessage('assistant', JSON.stringify(responseJson));
                setTimeout(generateWhatsAppLink, 500);
            } catch (error) {
                console.error("Erro no Diagnóstico:", error);
                const errorMsg = { responseText: 'Não consegui gerar um diagnóstico agora, mas não se preocupe. Vamos avançar para o atendimento com a nossa equipa.' };
                await saveMessage('assistant', JSON.stringify(errorMsg));
                generateWhatsAppLink();
            }
        }
        
        async function generateWhatsAppLink() {
            const introText = "Olá! Vim através da assistente Centelha.";
            const summary = `\n\n*Resumo do Atendimento:*\n- *Cliente:* ${appState.customerData.name}\n- *Moto:* ${appState.customerData.moto}\n- *Problema:* ${appState.customerData.problem}`;
            const preAnalysisSection = appState.customerData.preAnalysis ? `\n\n*Pré-Análise da Centelha:*\n${appState.customerData.preAnalysis}` : '';
            const fullText = introText + summary + preAnalysisSection;
            const encodedText = encodeURIComponent(fullText);
            const whatsappUrl = `https://wa.me/${config.whatsappNumber}?text=${encodedText}`;
            const transferMessage = { responseText: `Obrigado pelas informações! Para agilizar seu atendimento, preparei um resumo. Clique no botão para enviar no WhatsApp ou copie o texto. [BUTTON:Falar com a Equipa|${whatsappUrl}] [COPYBUTTON:Copiar Resumo|${fullText}]` };
            // Salva a mensagem final. O listener vai renderizá-la.
            await saveMessage('assistant', JSON.stringify(transferMessage));
        }

        // CORREÇÃO: Função chamada pelo listener, usa o estado atual já sincronizado.
        async function handleConversation() {
            toggleThinking(true);
            renderQuickReplies([]);
            try {
                // A história já está atualizada pelo listener, então a chamada é segura.
                if (appState.conversationHistory.length === 0) {
                     throw new Error("Tentativa de chamar a IA com histórico vazio.");
                }
                const jsonResponse = await callBackendAPI({ history: appState.conversationHistory, systemPrompt });
                appState.customerData = { ...appState.customerData, ...jsonResponse.extractedData };
                
                // Salva a resposta da IA. O listener vai renderizar e decidir o próximo passo.
                await saveMessage('assistant', JSON.stringify(jsonResponse));
                
                const allDataCollected = appState.customerData.name && appState.customerData.moto && appState.customerData.problem;
                if (jsonResponse.conversationState === 'READY_FOR_DIAGNOSIS' || allDataCollected) {
                    setTimeout(getDiagnosis, 500);
                }
            } catch (error) {
                console.error("Erro na Conversa:", error);
                const errorMsg = { responseText: "Desculpe, tive um pequeno curto-circuito aqui. Poderia repetir a sua última mensagem, por favor?" };
                await saveMessage('assistant', JSON.stringify(errorMsg));
            }
        }
        
        // CORREÇÃO: Função simplificada. Apenas salva a mensagem do usuário.
        async function handleSend() {
            const userInput = elements.chatInput.value.trim();
            if (userInput === '' || appState.isThinking) return;
            
            const textToSave = userInput;
            elements.chatInput.value = '';
            renderQuickReplies([]);

            // Apenas salva a mensagem do usuário. O listener `listenToMessages`
            // vai detectar essa nova mensagem e chamar `handleConversation`.
            await saveMessage('user', textToSave);
        }
        
        // CORREÇÃO: Função simplificada. Apenas salva a mensagem inicial.
        async function startConversation() {
            const welcomeMessage = {
                responseText: "Olá! Sou a Centelha, a sua assistente da Oficina FG Motos. Para começarmos, qual é o seu nome?",
                quickReplies: ["Meu nome é...", "Queria saber o endereço"]
            };
            // Salva a mensagem de boas-vindas. O listener vai renderizá-la.
            await saveMessage('assistant', JSON.stringify(welcomeMessage));
        }

        function attachEventListeners() {
            elements.sendBtn.addEventListener('click', handleSend);
            elements.chatInput.addEventListener('keydown', (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); handleSend(); } });
            elements.newChatBtn.addEventListener('click', () => { showModal("Tem a certeza de que deseja iniciar uma nova conversa?", createNewChat); });
            elements.modal.cancelBtn.addEventListener('click', hideModal);
            elements.chatMessages.addEventListener('click', (e) => {
                const target = e.target.closest('button[data-copytext]');
                if (target) {
                    navigator.clipboard.writeText(target.dataset.copytext).then(() => {
                        target.textContent = 'Copiado!';
                        setTimeout(() => { target.textContent = 'Copiar Resumo'; }, 2000);
                    });
                }
            });
        }
        
        async function startApp() {
            lucide.createIcons();
            attachEventListeners();
            const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
            if (!firebaseConfig || !firebaseConfig.projectId) {
                addMessageToUI('assistant', 'Aviso: A configuração do servidor está em falta. O chat não pode funcionar.', 'err-config');
                return;
            }
            try {
                const app = initializeApp(firebaseConfig);
                appState.db = getFirestore(app);
                appState.auth = getAuth(app);
                onAuthStateChanged(appState.auth, async (user) => {
                    if (user && !appState.isAuthReady) { 
                        appState.userId = user.uid;
                        appState.isAuthReady = true;
                        await createNewChat();
                    }
                });
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    await signInWithCustomToken(appState.auth, __initial_auth_token);
                } else {
                    await signInAnonymously(appState.auth);
                }
            } catch (error) {
                console.error("Falha na inicialização do Firebase:", error);
                addMessageToUI('assistant', 'Erro de ligação com os nossos sistemas. Por favor, recarregue a página.', `err-firebase-init`);
            }
        }
        window.onload = startApp;
    </script>
</body>
</html>
