<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Centelha - Assistente Inteligente | Oficina FG Motos</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Google Fonts: Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@0.378.0/dist/umd/lucide.min.js"></script>

    <style>
        /* Estilização base com um tema mais sofisticado */
        body {
            font-family: 'Inter', sans-serif;
            background: #111827; /* Fundo escuro */
        }

        /* Animação para surgimento suave das mensagens */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .chat-message {
            animation: fadeIn 0.3s ease-out;
        }

        /* Estilização da barra de rolagem */
        #chat-window::-webkit-scrollbar { width: 6px; }
        #chat-window::-webkit-scrollbar-track { background: transparent; }
        #chat-window::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 10px; }
        #chat-window::-webkit-scrollbar-thumb:hover { background: #6b7280; }

        /* Animação para o indicador de "digitando..." */
        .typing-indicator span {
            height: 8px;
            width: 8px;
            float: left;
            margin: 0 1px;
            background-color: #9ca3af;
            display: block;
            border-radius: 50%;
            opacity: 0.4;
            animation: bob 1s infinite;
        }
        .typing-indicator span:nth-of-type(2) { animation-delay: 0.2s; }
        .typing-indicator span:nth-of-type(3) { animation-delay: 0.4s; }
        @keyframes bob {
            10% { transform: translateY(-6px); opacity: 1; }
            50% { transform: translateY(0); opacity: 0.4; }
        }
        .chat-button {
            text-decoration: none !important;
        }
    </style>
</head>
<body class="flex items-center justify-center h-screen p-4">

    <!-- Container Principal do Chat -->
    <div id="chat-container" class="w-full max-w-lg h-full sm:h-[95vh] sm:max-h-[750px] bg-gray-800 text-white rounded-2xl shadow-2xl flex flex-col overflow-hidden border border-gray-700">
        
        <!-- Cabeçalho do Chat -->
        <div id="chat-header" class="bg-gray-900/80 backdrop-blur-sm p-4 flex items-center justify-between gap-4 shadow-lg z-10 border-b border-gray-700">
            <div class="flex items-center gap-3">
                <div class="w-12 h-12 bg-gradient-to-br from-yellow-400 to-orange-500 rounded-full flex items-center justify-center shadow-lg ring-2 ring-yellow-500/50">
                    <i data-lucide="sparkles" class="h-6 w-6 text-white"></i>
                </div>
                <div>
                    <h2 class="text-white text-lg font-bold">Centelha</h2>
                    <span id="status-indicator" class="text-green-400 text-xs flex items-center gap-1.5"><div class="w-2 h-2 bg-green-400 rounded-full animate-pulse"></div>Online</span>
                </div>
            </div>
            <button id="new-chat-btn" title="Nova Conversa" class="p-2 text-gray-400 hover:text-white hover:bg-gray-700 rounded-full transition-colors">
                <i data-lucide="rotate-cw" class="h-5 w-5"></i>
            </button>
        </div>

        <!-- Janela de Mensagens -->
        <div id="chat-window" class="flex-1 p-4 sm:p-6 overflow-y-auto bg-gray-800">
            <div id="chat-messages" class="flex flex-col gap-4">
                <!-- Mensagens inseridas via JavaScript -->
            </div>
        </div>
        
        <!-- Sugestões de Respostas Rápidas -->
        <div id="quick-replies-container" class="p-2 pt-0 flex flex-wrap gap-2 justify-start px-4">
            <!-- Botões de resposta rápida inseridos aqui -->
        </div>

        <!-- Área de Input -->
        <div id="chat-input-container" class="p-4 bg-gray-800 border-t border-gray-700">
            <div class="flex items-center bg-gray-900 rounded-full px-2">
                <input type="text" id="chat-input" placeholder="Digite a sua mensagem..." class="flex-1 bg-transparent p-3 text-gray-200 placeholder-gray-500 focus:outline-none">
                <button id="send-btn" class="p-3 rounded-full bg-gradient-to-br from-yellow-400 to-orange-500 hover:opacity-90 transition-opacity disabled:opacity-50 disabled:cursor-not-allowed">
                    <i data-lucide="send" class="h-6 w-6 text-white"></i>
                </button>
            </div>
        </div>
    </div>
    
    <!-- Modal de Confirmação -->
    <div id="confirmation-modal" class="fixed inset-0 bg-black/60 items-center justify-center hidden z-50">
        <div class="bg-gray-800 border border-gray-700 rounded-lg p-6 shadow-xl max-w-sm mx-4 text-center">
            <h3 class="text-lg font-bold text-white mb-2">Confirmar Ação</h3>
            <p id="modal-text" class="text-gray-300 mb-6">Tem a certeza de que deseja iniciar uma nova conversa? Todo o histórico atual será perdido.</p>
            <div class="flex justify-center gap-4">
                <button id="cancel-btn" class="px-4 py-2 bg-gray-600 hover:bg-gray-500 text-white font-semibold rounded-lg transition-colors">Cancelar</button>
                <button id="confirm-btn" class="px-4 py-2 bg-red-600 hover:bg-red-500 text-white font-semibold rounded-lg transition-colors">Confirmar</button>
            </div>
        </div>
    </div>


    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, collection, addDoc, onSnapshot, query, serverTimestamp, orderBy, deleteDoc, getDocs, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- Configuração do Firebase (para GitHub) ---
        const firebaseConfig = {
            apiKey: "AIzaSyBYSzG5XKIvCa1iFVOjALdooVSf1HsyeJ8",
            authDomain: "centelha-e931b.firebaseapp.com",
            projectId: "centelha-e931b",
            storageBucket: "centelha-e931b.appspot.com", // Formato padrão para o SDK
            messagingSenderId: "639426563285",
            appId: "1:639426563285:web:676bc24c3f32475478a65c",
            measurementId: "G-BR4P0XVTPB"
        };

        // IMPORTANTE: Insira aqui a sua chave da API Gemini
        const apiKey = "AIzaSyBTMLgu3Dqao9-EhnfaqIWYpXMNqU1ixRg"; 

        // --- Elementos do DOM ---
        const elements = {
            chatInput: document.getElementById('chat-input'),
            sendBtn: document.getElementById('send-btn'),
            chatMessages: document.getElementById('chat-messages'),
            chatWindow: document.getElementById('chat-window'),
            newChatBtn: document.getElementById('new-chat-btn'),
            quickRepliesContainer: document.getElementById('quick-replies-container'),
            modal: {
                container: document.getElementById('confirmation-modal'),
                text: document.getElementById('modal-text'),
                cancelBtn: document.getElementById('cancel-btn'),
                confirmBtn: document.getElementById('confirm-btn')
            }
        };

        // --- Estado da Aplicação ---
        let appState = {
            isAuthReady: false,
            userId: null,
            chatId: null,
            isThinking: false,
            conversationHistory: [],
            customerData: { name: '', moto: '', problem: '' },
            db: null,
            auth: null,
            unsubscribe: null, 
        };
        
        // --- CÉREBRO DA CENTELHA: Instruções para a IA ---
        const systemPrompt = `
            Você é a Centelha, uma assistente virtual especialista em motocicletas da "Oficina FG Motos".
            Sua personalidade é amigável, técnica e eficiente.
            Seu objetivo é coletar NOME, MODELO DA MOTO e o PROBLEMA.

            RESPONDA SEMPRE EM FORMATO JSON VÁLIDO com a seguinte estrutura:
            {
              "responseText": "Sua resposta conversacional para o usuário.",
              "conversationState": "STATE",
              "extractedData": { "name": "...", "moto": "...", "problem": "..." },
              "quickReplies": ["Opção 1", "Opção 2"]
            }

            REGRAS DE LÓGICA:
            1. 'conversationState': Mude o estado conforme o andamento:
               - ASKING_FOR_DATA: Quando ainda precisa de alguma das três informações.
               - READY_FOR_DIAGNOSIS: Quando JÁ TEM nome, moto E problema.
               - GENERAL_QUESTION: Se o usuário fez uma pergunta geral (ex: endereço, horário). Responda e depois volte ao fluxo principal de coleta de dados.

            2. 'extractedData': Preencha com os dados da MENSAGEM MAIS RECENTE. Mantenha os dados já coletados. Se o usuário corrigir uma informação, atualize-a. Se a informação não for fornecida, deixe como string vazia.

            3. 'quickReplies': Ofereça sugestões ÚTEIS. Ex: ao perguntar o problema, sugira ["Não liga", "Faz barulho estranho"]. Mantenha o array vazio ([]) se não houver boas sugestões.

            4. 'responseText': Seja claro. Peça um dado de cada vez. Se já tiver o nome, peça a moto. Se já tiver a moto, peça o problema.

            5. NUNCA use markdown (*, #, etc.) em 'responseText'.

            INFORMAÇÕES DA OFICINA:
            - Endereço: Av. Fabio Zahran, 6628, Vila Carvalho, Campo Grande-MS.
            - WhatsApp: +5567999271603
            - Horário: Segunda a Sexta, das 8h às 18h.
        `;

        // --- Funções da Interface (UI) ---

        function toggleThinking(isThinking) {
            appState.isThinking = isThinking;
            elements.chatInput.disabled = isThinking;
            elements.sendBtn.disabled = isThinking;
            elements.chatInput.placeholder = isThinking ? "Centelha está a pensar..." : "Digite a sua mensagem...";
            
            const typingIndicator = document.querySelector('.typing-indicator-container');
            if (typingIndicator) typingIndicator.remove();
            
            if (isThinking) {
                const indicatorHTML = `
                    <div class="w-full flex justify-start typing-indicator-container chat-message">
                        <div class="bg-gray-700 text-gray-800 p-3 rounded-2xl rounded-bl-lg max-w-sm">
                            <div class="typing-indicator"><span></span><span></span><span></span></div>
                        </div>
                    </div>`;
                elements.chatMessages.insertAdjacentHTML('beforeend', indicatorHTML);
                scrollToBottom();
            }
        }
        
        function addMessageToUI(sender, text, quickReplies = []) {
            const typingIndicator = document.querySelector('.typing-indicator-container');
            if (typingIndicator) typingIndicator.remove();

            const messageContainer = document.createElement('div');
            messageContainer.className = `w-full flex chat-message ${sender === 'user' ? 'justify-end' : 'justify-start'}`;
            
            const buttonRegex = /\[BUTTON:(.+?)\|(.+?)\]/g;
            let sanitizedText = text.replace(/</g, "&lt;").replace(/>/g, "&gt;");
            
            const textWithButtons = sanitizedText.replace(buttonRegex, (match, buttonText, url) => {
                 return `<a href="${url}" target="_blank" class="chat-button block text-center mt-3 bg-gradient-to-br from-yellow-400 to-orange-500 text-white font-bold py-2.5 px-4 rounded-full hover:opacity-90 transition-opacity no-underline">${buttonText}</a>`;
            });

            const messageBubble = sender === 'user'
                ? `<div class="bg-gradient-to-br from-yellow-400 to-orange-500 text-white p-3 rounded-2xl rounded-br-lg max-w-md shadow-md"><p>${textWithButtons}</p></div>`
                : `<div class="bg-gray-700 text-gray-100 p-3 rounded-2xl rounded-bl-lg max-w-md shadow-md"><p>${textWithButtons}</p></div>`;
            
            messageContainer.innerHTML = messageBubble;
            elements.chatMessages.appendChild(messageContainer);
            renderQuickReplies(quickReplies);
            scrollToBottom();
        }

        function renderQuickReplies(replies = []) {
            elements.quickRepliesContainer.innerHTML = '';
            if (!replies || replies.length === 0) return;

            replies.forEach(reply => {
                const button = document.createElement('button');
                button.textContent = reply;
                button.className = "px-3 py-1.5 bg-gray-700 text-gray-200 rounded-full text-sm hover:bg-gray-600 transition-colors";
                button.onclick = () => {
                    elements.chatInput.value = reply;
                    handleSend();
                };
                elements.quickRepliesContainer.appendChild(button);
            });
        }
        
        function scrollToBottom() {
            elements.chatWindow.scrollTop = elements.chatWindow.scrollHeight;
        }
        
        function showModal(text, onConfirm) {
            elements.modal.text.textContent = text;
            elements.modal.container.classList.remove('hidden');
            elements.modal.container.classList.add('flex');
            
            const newConfirmBtn = elements.modal.confirmBtn.cloneNode(true);
            elements.modal.confirmBtn.parentNode.replaceChild(newConfirmBtn, elements.modal.confirmBtn);
            elements.modal.confirmBtn = newConfirmBtn;
            
            elements.modal.confirmBtn.onclick = () => {
                onConfirm();
                hideModal();
            };
        }

        function hideModal() {
            elements.modal.container.classList.add('hidden');
            elements.modal.container.classList.remove('flex');
        }

        // --- Funções do Firestore ---

        async function saveMessage(sender, text) {
            if (!appState.isAuthReady || !appState.chatId || !appState.db) return;
            try {
                const messagesCol = collection(appState.db, `users/${appState.userId}/chats/${appState.chatId}/messages`);
                await addDoc(messagesCol, {
                    sender,
                    text,
                    createdAt: serverTimestamp()
                });
            } catch (error) {
                console.error("Erro ao guardar mensagem:", error);
            }
        }
        
        function listenToMessages() {
            if (appState.unsubscribe) appState.unsubscribe();
            
            const messagesCol = collection(appState.db, `users/${appState.userId}/chats/${appState.chatId}/messages`);
            const q = query(messagesCol, orderBy("createdAt"));

            appState.unsubscribe = onSnapshot(q, (snapshot) => {
                if (snapshot.docChanges().length === 0 && !snapshot.empty) return;
                
                elements.chatMessages.innerHTML = ''; 
                appState.conversationHistory = [];
                
                if (snapshot.empty) {
                    startConversation();
                } else {
                    snapshot.docs.forEach(doc => {
                        const data = doc.data();
                        addMessageToUI(data.sender, data.text);
                        appState.conversationHistory.push({
                            role: data.sender === 'user' ? 'user' : 'model',
                            parts: [{ text: data.text }]
                        });
                    });
                }
                 toggleThinking(false);
            }, (error) => {
                console.error("Erro ao ouvir mensagens:", error);
                addMessageToUI('assistant', 'Não foi possível carregar o histórico. Por favor, atualize a página.');
                 toggleThinking(false);
            });
        }
        
        async function createNewChat() {
            if (!appState.isAuthReady || !appState.db) return;
            
            toggleThinking(true);
            elements.chatMessages.innerHTML = '';
            appState.conversationHistory = [];
            appState.customerData = { name: '', moto: '', problem: '' };
            
            try {
                const chatsCol = collection(appState.db, `users/${appState.userId}/chats`);
                const newChatRef = await addDoc(chatsCol, { createdAt: serverTimestamp(), userId: appState.userId });
                appState.chatId = newChatRef.id;
                listenToMessages();
            } catch (error) {
                console.error("Erro ao criar novo chat:", error);
                toggleThinking(false);
            }
        }

        async function findOrCreateChat() {
            if (!appState.isAuthReady || !appState.db) return;
            toggleThinking(true);
            const chatsCol = collection(appState.db, `users/${appState.userId}/chats`);
            const q = query(chatsCol, orderBy("createdAt", "desc"));
            
            try {
                const querySnapshot = await getDocs(q);
                if (querySnapshot.empty) {
                    await createNewChat();
                } else {
                    appState.chatId = querySnapshot.docs[0].id;
                    listenToMessages();
                }
            } catch(error) {
                 console.error("Erro ao procurar chat:", error);
                 addMessageToUI('assistant', 'Erro ao carregar a sua conversa. A tentar novamente.');
                 toggleThinking(false);
            }
        }
        
        async function clearChatHistory() {
             if (!appState.isAuthReady || !appState.chatId || !appState.db) {
                elements.chatMessages.innerHTML = '';
                appState.conversationHistory = [];
                startConversation();
                return;
             }
            toggleThinking(true);
            if (appState.unsubscribe) appState.unsubscribe();
            
            try {
                const messagesCol = collection(appState.db, `users/${appState.userId}/chats/${appState.chatId}/messages`);
                const snapshot = await getDocs(messagesCol);
                const deletePromises = snapshot.docs.map(doc => deleteDoc(doc.ref));
                await Promise.all(deletePromises);
                
                const chatDoc = doc(appState.db, `users/${appState.userId}/chats`, appState.chatId);
                await deleteDoc(chatDoc);
                
                appState.chatId = null;
                await createNewChat();

            } catch (error) {
                console.error("Erro ao limpar histórico:", error);
                addMessageToUI('assistant', 'Ocorreu um erro ao limpar a conversa. Por favor, tente novamente.');
                toggleThinking(false);
            }
         }

        // --- Funções da IA (Gemini) ---

        async function callGeminiAPI(currentHistory) {
             if (!apiKey) {
                throw new Error("A chave da API Gemini não foi definida.");
            }
            const historyWithoutSystemPrompt = currentHistory.slice(1);

            const payload = {
                contents: [
                    { role: "model", parts: [{ text: "Ok, entendi as regras." }] },
                    ...historyWithoutSystemPrompt
                ],
                systemInstruction: {
                    role: "system",
                    parts: [{ text: systemPrompt }]
                },
                generationConfig: {
                    maxOutputTokens: 800,
                    temperature: 0.7,
                    responseMimeType: "application/json",
                    responseSchema: {
                        type: "OBJECT",
                        properties: {
                            "responseText": { "type": "STRING" },
                            "conversationState": { "type": "STRING" },
                            "extractedData": {
                                type: "OBJECT",
                                properties: {
                                    "name": { "type": "STRING" },
                                    "moto": { "type": "STRING" },
                                    "problem": { "type": "STRING" }
                                },
                                 required: ["name", "moto", "problem"]
                            },
                            "quickReplies": { "type": "ARRAY", "items": { "type": "STRING" } }
                        },
                        required: ["responseText", "conversationState", "extractedData", "quickReplies"]
                    }
                }
            };

            const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${apiKey}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                const errorBody = await response.text();
                throw new Error(`API call failed with status: ${response.status}. Body: ${errorBody}`);
            }
            return response.json();
        }

        async function getDiagnosis() {
            toggleThinking(true);
            const diagnosisPrompt = `
                Baseado nos dados coletados, forneça um diagnóstico preliminar para o cliente.
                CLIENTE: ${appState.customerData.name}
                MOTO: ${appState.customerData.moto}
                PROBLEMA: ${appState.customerData.problem}

                Forneça 2 ou 3 causas mais comuns para o problema descrito, de forma clara e simples.
                Seja breve e direto.
                NÃO use NENHUM tipo de formatação, como markdown (negrito com **, itálico com *, etc). Responda em texto puro.
                Ao final, inclua OBRIGATORIAMENTE este aviso: "Lembre-se, ${appState.customerData.name}, que esta é uma análise inicial. Para um diagnóstico preciso e seguro, o ideal é trazer sua ${appState.customerData.moto} para nossos mecânicos avaliarem aqui na oficina."
            `;
            
            try {
                const payload = {
                    contents: [{ role: 'user', parts: [{ text: diagnosisPrompt }] }]
                };
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${apiKey}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                 if (!response.ok) throw new Error("A API de diagnóstico falhou.");
                const data = await response.json();
                
                if (data.candidates?.[0]?.content?.parts?.[0]?.text) {
                    const diagnosisText = data.candidates[0].content.parts[0].text.trim();
                    await saveMessage('assistant', diagnosisText);
                    setTimeout(generateWhatsAppLink, 1000);
                } else {
                    throw new Error('Resposta de diagnóstico inválida.');
                }
            } catch (error) {
                console.error("Diagnosis Error:", error);
                const errorMsg = 'Não consegui gerar um diagnóstico agora, mas não se preocupe. Vamos avançar para o atendimento com a nossa equipa.';
                await saveMessage('assistant', errorMsg);
                generateWhatsAppLink();
            }
        }
        
        async function generateWhatsAppLink() {
            const introText = "Olá! Vim através da assistente Centelha.";
            const summary = `\n\n*Resumo do Atendimento:*\n- *Cliente:* ${appState.customerData.name}\n- *Moto:* ${appState.customerData.moto}\n- *Problema:* ${appState.customerData.problem}`;
            const encodedText = encodeURIComponent(introText + summary);
            const whatsappUrl = `https://wa.me/5567999271603?text=${encodedText}`;
            
            const transferMessage = `Obrigado pelas informações! Para agilizar seu atendimento, preparei um resumo. Clique no botão abaixo para enviar a mensagem já pronta no seu WhatsApp e falar com a nossa equipa. [BUTTON:Falar com a Equipa|${whatsappUrl}]`;
            
            await saveMessage('assistant', transferMessage);
            toggleThinking(false);
        }

        // --- Lógica Principal da Conversa ---

        async function handleConversation(userInput) {
            toggleThinking(true);

            try {
                const data = await callGeminiAPI(appState.conversationHistory);
                
                if (data.candidates?.[0]?.content?.parts?.[0]?.text) {
                    let jsonResponse;
                    try {
                       jsonResponse = JSON.parse(data.candidates[0].content.parts[0].text);
                    } catch (e) {
                        console.error("Erro ao fazer parse do JSON da IA:", e);
                        throw new Error("A resposta da IA não é um JSON válido.");
                    }

                    appState.customerData = { ...appState.customerData, ...jsonResponse.extractedData };
                    
                    const assistantResponse = jsonResponse.responseText;
                    await saveMessage('assistant', assistantResponse);
                    appState.conversationHistory.push({ role: 'model', parts: [{ text: JSON.stringify(jsonResponse) }] });

                    renderQuickReplies(jsonResponse.quickReplies);

                    const allDataCollected = appState.customerData.name && appState.customerData.moto && appState.customerData.problem;

                    if (jsonResponse.conversationState === 'READY_FOR_DIAGNOSIS' || allDataCollected) {
                        setTimeout(getDiagnosis, 500);
                    } else {
                        toggleThinking(false);
                    }

                } else {
                    throw new Error('Resposta da API inválida.');
                }
            } catch (error) {
                console.error("Conversation Error:", error);
                const errorMsg = "Desculpe, tive um pequeno curto-circuito aqui. Poderia repetir a sua última mensagem, por favor?";
                addMessageToUI('assistant', errorMsg);
                appState.conversationHistory.pop(); 
                toggleThinking(false);
            }
        }
        
        async function handleSend() {
            const userInput = elements.chatInput.value.trim();
            if (userInput === '' || appState.isThinking) return;

            await saveMessage('user', userInput);
            elements.chatInput.value = '';
            renderQuickReplies([]);

            await handleConversation(userInput);
        }
        
        function startConversation() {
             const welcomeMessage = "Olá! Sou a Centelha, a sua assistente da Oficina FG Motos. Para começarmos, qual é o seu nome?";
             addMessageToUI('assistant', welcomeMessage, ["Meu nome é...", "Queria saber o endereço"]);
             saveMessage('assistant', welcomeMessage);
             
             appState.conversationHistory = [{
                 role: 'model',
                 parts: [{ text: welcomeMessage }]
             }];
             toggleThinking(false);
         }

        // --- Inicialização e Event Listeners ---

        async function startApp() {
            lucide.createIcons();
            
            elements.sendBtn.addEventListener('click', handleSend);
            elements.chatInput.addEventListener('keydown', (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); handleSend(); } });
            elements.newChatBtn.addEventListener('click', () => {
                showModal("Tem a certeza de que deseja apagar esta conversa e começar uma nova?", clearChatHistory);
            });
            elements.modal.cancelBtn.addEventListener('click', hideModal);
            
            if (!firebaseConfig || !firebaseConfig.projectId) {
                console.error("Configuração do Firebase ausente ou inválida.");
                addMessageToUI('assistant', 'Aviso: A configuração do Firebase está em falta. O chat não pode funcionar.');
                toggleThinking(true);
                return;
            }
            
            try {
                setLogLevel('error');
                const app = initializeApp(firebaseConfig);
                appState.db = getFirestore(app);
                appState.auth = getAuth(app);
                
                onAuthStateChanged(appState.auth, async (user) => {
                    if (user && !appState.isAuthReady) { 
                        appState.userId = user.uid;
                        appState.isAuthReady = true;
                        await findOrCreateChat();
                    }
                });

                await signInAnonymously(appState.auth);

            } catch (error) {
                console.error("Falha na inicialização do Firebase ou Autenticação:", error);
                if (error.code === 'auth/configuration-not-found') {
                    addMessageToUI('assistant', '<b>Erro de Configuração:</b> O método de login "Anónimo" precisa ser ativado no seu projeto Firebase. <br><br> 1. Vá para o seu <b>Console do Firebase</b>. <br> 2. Clique em <b>Authentication</b>. <br> 3. Vá para a aba <b>Sign-in method</b>. <br> 4. Ative o provedor <b>Anónimo</b>.');
                } else {
                    addMessageToUI('assistant', 'Erro de ligação com os nossos sistemas. Por favor, recarregue a página.');
                }
                toggleThinking(true); 
            }
        }

        window.onload = startApp;
    </script>
</body>
</html>
